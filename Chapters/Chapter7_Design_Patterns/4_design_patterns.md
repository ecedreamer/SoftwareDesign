## Design Patterns
Design patterns are reusable solutions to common problems encountered in software design. They provide a structured approach to solving design problems and promote code reuse, maintainability, and scalability. 

### Creational Patterns:
- **Singleton Pattern**: Ensures that a class has only one instance and provides a global point of access to that instance.
- **Factory Method Pattern**: Defines an interface for creating an object, but allows subclasses to alter the type of objects that will be created.
- **Abstract Factory Pattern**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

### Structural Patterns:
- **Adapter Pattern**: Allows objects with incompatible interfaces to work together by providing a wrapper that converts the interface of one class into another interface.
- **Decorator Pattern**: Allows behavior to be added to individual objects dynamically, without affecting the behavior of other objects from the same class.
- **Facade Pattern**: Provides a simplified interface to a set of interfaces in a subsystem, making it easier to use.
- **Proxy Pattern**: Provides a surrogate or placeholder for another object to control access to it.

### Behavioral Patterns:
- **Observer Pattern**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
- **Strategy Pattern**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
- **Command Pattern**: Encapsulates a request as an object, thereby allowing parameterization of clients with queues, requests, and operations.
- **State Pattern**: The State design pattern allows an object to alter its behavior when its internal state changes, making it appear as if the object changes its class. 
- **Iterator Pattern**: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
- **Chain of Responsibility Pattern**: Allows a set of classes to handle a request one by one in a chain until the request is handled.


## References:
- Read this mendatorily: https://refactoring.guru/design-patterns
